/*
 * @Description: main.ts
 * @Date: 2021-07-08 16:00:18
 * @Author: LeiLiu
 */
import { app, BrowserWindow, ipcMain, Tray, Menu, screen/* , dialog */ } from 'electron';
import * as path from 'path';
import dayjs from 'dayjs';

const isDev = process.env.NODE_ENV === 'development';
// 获取环境获取静态资源路径
const assetsPath = !isDev ? process.resourcesPath : app.getAppPath();
const iconPath = path.join(assetsPath, 'assets/icons/icon.png');

// console.log(process);
// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const REMIND_WINDOW_WEBPACK_ENTRY: string;
declare const REMIND_WINDOW_PRELOAD_WEBPACK_ENTRY: string;


// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) { // eslint-disable-line global-require
  app.quit();
}

let mainWindow: BrowserWindow; // 主进程
let tray: Tray; // 系统托盘 借助Tray实现
let remindWindow: BrowserWindow; // 提醒进程

const createWindow = (): void => {
  // 检查更新
  // checkUpdate();

  // Create the browser window.
  mainWindow = new BrowserWindow({
    frame: isDev, // 创建无边框窗口
    resizable: isDev,
    height: 600,
    width: 1200,
    icon: iconPath,
    backgroundColor: '#191622',
    webPreferences:{
      backgroundThrottling: false,
      // 访问Node.js API
      // nodeIntegration:true,
      // contextIsolation: false,
      webSecurity: true,
      nodeIntegration: false,
      enableRemoteModule: false,
      contextIsolation: true,
      nodeIntegrationInWorker: false,
      nodeIntegrationInSubFrames: false,
      preload: REMIND_WINDOW_PRELOAD_WEBPACK_ENTRY
    }
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // 移除菜单，若不进行此操作，可使用ctrl+shift+i打开开发者工具
  !isDev && mainWindow.removeMenu();

  // Open the DevTools.
  isDev && mainWindow.webContents.openDevTools();

  // 系统托盘图标 https://www.cnblogs.com/loaderman/p/12163562.html
  tray = new Tray(iconPath); // 实例化一个tray对象，构造函数的唯一参数是需要在托盘中显示的图标url
  tray.setToolTip('Tasky'); // // 鼠标移到托盘中应用程序的图标上时，显示的文本
  // 点击图标的响应事件，这里是切换主窗口的显示和隐藏
  tray.on('click', () => {
    if (mainWindow.isVisible()) {
      mainWindow.hide();
    } else {
      mainWindow.show();
    }
  });
  // 右键点击图标时，出现的菜单，通过Menu.buildFromTemplate定制，这里只包含退出程序的选项。
  // 只支持 platform darwin,win32
  tray.on('right-click', () => {
    const menuConfig = Menu.buildFromTemplate([
      {
        label: 'Quit',
        click: () => app.quit()
      }
    ]);
    tray.popUpContextMenu(menuConfig);
  });
};

// 创建子进程
function createRemindWindow(task: string) {
  if (remindWindow) remindWindow.close();

  // 创建提醒窗口
  remindWindow = new BrowserWindow({
    height: 450,
    width: 360,
    resizable: isDev,
    // frame: false,
    icon: iconPath,
    show: false,
    webPreferences:{
      webSecurity: true,
      nodeIntegration: false,
      enableRemoteModule: false,
      contextIsolation: true,
      nodeIntegrationInWorker: false,
      nodeIntegrationInSubFrames: false,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
    }
  });

  // remindWindow.removeMenu();
  // 获取屏幕尺寸
  const size = screen.getPrimaryDisplay().workAreaSize;

  // 获取托盘位置的y坐标（windows在右下角，Mac在右上角）
  const { y } = tray.getBounds();
  console.log(y);
  // 获取窗口的宽高
  const { height, width } = remindWindow.getBounds();
  // 计算窗口的y坐标
  const yPosition = process.platform === 'darwin' ? y : y - height;
  // setBounds设置窗口的位置
  remindWindow.setBounds({
    x: size.width - width, // x坐标为屏幕宽度 - 窗口宽度
    y: yPosition,
    height,
    width 
  });
  // 当有多个应用时，提醒窗口始终处于最上层
  remindWindow.setAlwaysOnTop(true);
  // remindWindow.loadURL(`file://${__dirname}/src/remind.html`);
  remindWindow.loadURL(REMIND_WINDOW_WEBPACK_ENTRY);
  remindWindow.show();

  isDev && remindWindow.webContents.openDevTools();

  // 主进程发送消息给渲染进程
  // remindWindow.on('show', () => {
  //   remindWindow.webContents.send('setTask', task);
  // });
  remindWindow.webContents.on('did-finish-load', () => {
    remindWindow.webContents.send('setTask', task);
  });
  remindWindow.on('closed', () => {
    console.log('remindWindow:closed');
    remindWindow = null;
  });
  setTimeout( () => {
    remindWindow && remindWindow.close();
  }, 50 * 1000);
}

// 主进程通过ipcMain接收消息(来自渲染进程中的ipcRenderer)
ipcMain.on('mainWindow:close', () => {
  mainWindow.hide();
});

ipcMain.on('remindWindow:close', () => {
  remindWindow.close();
});

ipcMain.on('setTaskTimer', (event, time: number, task) => {
  const now = dayjs().valueOf();
  const timeout = time - now;
  console.log(time, task);
  if (timeout > 0) {
    setTimeout(() => {
      createRemindWindow(task);
    }, timeout); 
  }
});

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);
// Electron会在初始化完成并且准备好创建浏览器窗口时调用这个方法
// 部分 API 在 ready 事件触发后才能使用。
// app.whenReady().then(createWindow);

// 设置开机自启
// app.setLoginItemSettings({
//   openAtLogin: true,
//   // 苹果系统隐藏式启动
//   openAsHidden: false
// });

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
